/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Catley Lakeman Ltd. 
 The moral rights of the author, David Rees, have been asserted.

 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/

 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
*/

/*! \file mcautocallengine.hpp
    \brief Monte Carlo engine for Autocalls
*/

#ifndef quantlib_mc_autocall_engine_hpp
#define quantlib_mc_autocall_engine_hpp

#include <ql/experimental/exoticoptions/autocall.hpp>
#include <ql/pricingengines/mcsimulation.hpp>
#include <ql/processes/blackscholesprocess.hpp>
#include <ql/processes/stochasticprocessarray.hpp>
#include <ql/exercise.hpp>

namespace QuantLib {
    namespace AutocallConstants {
        static const Size cNoIndex = -1;
    }

    template <class RNG = PseudoRandom, class S = Statistics>
    class MCAutocallEngine : public Autocall::engine,
                             public McSimulation<MultiVariate,RNG,S> {
      public:
        typedef typename McSimulation<MultiVariate,RNG,S>::path_generator_type
            path_generator_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::path_pricer_type
            path_pricer_type;
        typedef typename McSimulation<MultiVariate,RNG,S>::stats_type
            stats_type;
        MCAutocallEngine(const boost::shared_ptr<StochasticProcessArray>&,
                         Size stepsPerYear,
                         bool brownianBridge,
                         bool antitheticVariate,
                         Size requiredSamples,
                         Real requiredTolerance,
                         Size maxSamples,
                         BigNatural seed);

        void calculate() const {
            McSimulation<MultiVariate,RNG,S>::calculate(requiredTolerance_,
                                                        requiredSamples_,
                                                        maxSamples_);
            results_.value = this->mcModel_->sampleAccumulator().mean();

            if (RNG::allowsErrorEstimate)
            results_.errorEstimate =
                this->mcModel_->sampleAccumulator().errorEstimate();
        }
      private:
        // McSimulation implementation
        TimeGrid timeGrid() const;
        boost::shared_ptr<path_generator_type> pathGenerator() const {

            Size numAssets = processes_->size();

            TimeGrid grid = timeGrid();
            typename RNG::rsg_type gen =
                RNG::make_sequence_generator(numAssets*(grid.size()-1),seed_);

            return boost::shared_ptr<path_generator_type>(
                         new path_generator_type(processes_,
                                                 grid, gen, brownianBridge_));
        }
        boost::shared_ptr<path_pricer_type> pathPricer() const;

        // data members
        boost::shared_ptr<StochasticProcessArray> processes_;
        Size stepsPerYear_;
        Size requiredSamples_;
        Size maxSamples_;
        Real requiredTolerance_;
        bool brownianBridge_;
        BigNatural seed_;

        // Get the time to the strike date
        Time getStrikeTime() const
        {
            const Time t = processes_->time( arguments_.strikeDate_ );
            return t;
        }

        // Get all the times to each coupon
        void getCouponTimes( std::vector<Time>& couponTimes ) const
        {
            couponTimes.resize(0);

            // First date is start of schedule - not an actual coupon date
            for( Size i=1 ; i<arguments_.fixedSchedule_.size() ; i++ ) {
                const Time t = processes_->time( arguments_.fixedSchedule_[i] );
                if( couponTimes.size() > 0 ) {
                    QL_REQUIRE( t > couponTimes.back(), "coupon dates not sorted");
                }
                // Only require times in the future
                // Note no coupon on settle date (i.e. t==00 as per a bond)
                if( t > 0 )
                    couponTimes.push_back(t);
            }
        }

        // Get the times to dates generated by stepsPerYear
        void getRegularTimes( std::vector<Time>& regularTimes ) const
        {
            regularTimes.resize(0);

            // Assume that the last time is the last coupon 
            const Time end_time = processes_->time( arguments_.fixedSchedule_.dates().back() );

            // The regular dates march backwards from the end time
            const Time increment = 1.0 / stepsPerYear_;
            for( Time t=end_time ; t>0.0 ; t-=increment )
                regularTimes.push_back(t);

            std::sort( regularTimes.begin(), regularTimes.end() );
        }

        // Get the time grid and the indices
        TimeGrid getTimeGridAndIndices(
            Size& strikeDateIndex,
            std::vector<Size>& couponDateIndices
            ) const
        {
            std::vector<Time> gridTimes;

            // If the strike levels have not been set then the
            // strike date needs to be on the grid
            const Time strikeTime = getStrikeTime();
            const bool requireStrikeTime = arguments_.strikeLevels_.size() == 0;
            if( requireStrikeTime ) {
                // If stike time is in the past then it cannot be found from MC
                QL_REQUIRE( strikeTime>=0, "Must supply strike levels if strike date in the past."
                    << " Time to strike date = " << strikeTime );

                gridTimes.push_back(strikeTime);
            }

            // Create a sorted vector with all interesting dates
            // Do not assume that coupon times are on regular times
            // Grid dates are the union of coupon dates and the regular grid
            std::vector<Time> couponTimes;  getCouponTimes( couponTimes );
            std::vector<Time> regularTimes; getRegularTimes( regularTimes );

            gridTimes.insert( gridTimes.end(), couponTimes.begin(), couponTimes.end() );
            gridTimes.insert( gridTimes.end(), regularTimes.begin(), regularTimes.end() );

            std::sort( gridTimes.begin(), gridTimes.end() );

            TimeGrid grid( gridTimes.begin(), gridTimes.end() );

            // Find the indices of the strike and coupons
            strikeDateIndex = AutocallConstants::cNoIndex;
            if( requireStrikeTime )
                strikeDateIndex = grid.closestIndex( strikeTime );

            const Size numCoupons = couponTimes.size();
            couponDateIndices.resize( numCoupons );
            for( Size i=0 ; i<numCoupons ; ++i )
                couponDateIndices[i] = grid.closestIndex( couponTimes[i] );

            return grid;
        }
    };


    //! Monte Carlo Autocall-option engine factory
    template <class RNG = PseudoRandom, class S = Statistics>
    class MakeMCAutocallEngine {
      public:
        MakeMCAutocallEngine(
                    const boost::shared_ptr<StochasticProcessArray>&);
        // named parameters
        MakeMCAutocallEngine& withStepsPerYear(Size steps);
        MakeMCAutocallEngine& withBrownianBridge(bool b = true);
        MakeMCAutocallEngine& withAntitheticVariate(bool b = true);
        MakeMCAutocallEngine& withSamples(Size samples);
        MakeMCAutocallEngine& withAbsoluteTolerance(Real tolerance);
        MakeMCAutocallEngine& withMaxSamples(Size samples);
        MakeMCAutocallEngine& withSeed(BigNatural seed);
        // conversion to pricing engine
        operator boost::shared_ptr<PricingEngine>() const;
      private:
        boost::shared_ptr<StochasticProcessArray> process_;
        bool brownianBridge_, antithetic_;
        Size stepsPerYear_, samples_, maxSamples_;
        Real tolerance_;
        BigNatural seed_;
    };


    class AutocallMultiPathPricer : public PathPricer<MultiPath> {
      public:
        AutocallMultiPathPricer(
            const Autocall::arguments& arguments,
            const std::vector<DiscountFactor>& discounts,
            const Size& strikeDateIndex,
            const std::vector<Size>& couponDateIndices
            );
        
        Real operator()(const MultiPath& multiPath) const;
      private:
        Autocall::arguments arguments_;
        std::vector<DiscountFactor> discounts_;
        Size strikeDateIndex_;
        std::vector<Size> couponDateIndices_;
    };
    
    // template definitions

    template<class RNG, class S>
    inline MCAutocallEngine<RNG,S>::MCAutocallEngine(
                   const boost::shared_ptr<StochasticProcessArray>& processes,
                   Size stepsPerYear,
                   bool brownianBridge,
                   bool antitheticVariate,
                   Size requiredSamples,
                   Real requiredTolerance,
                   Size maxSamples,
                   BigNatural seed)
    : McSimulation<MultiVariate,RNG,S>(antitheticVariate, false),
      processes_(processes), stepsPerYear_(stepsPerYear),
      requiredSamples_(requiredSamples), maxSamples_(maxSamples), 
      requiredTolerance_(requiredTolerance), brownianBridge_(brownianBridge), 
      seed_(seed) {

        QL_REQUIRE(stepsPerYear != Null<Size>(), 
                   "stepsPerYear must be provided");
        
        QL_REQUIRE(stepsPerYear != 0,
                   "stepsPerYear must be positive, " << stepsPerYear <<
                   " not allowed");

        registerWith(processes_);
    }

    template <class RNG, class S>
    inline TimeGrid MCAutocallEngine<RNG,S>::timeGrid() const {
        Size strikeDateIndex;
        std::vector<Size> couponDateIndices;
        TimeGrid timeGrid = getTimeGridAndIndices( strikeDateIndex, couponDateIndices );
        return timeGrid;
    }

    template <class RNG, class S>
    inline
    boost::shared_ptr<typename MCAutocallEngine<RNG,S>::path_pricer_type>
    MCAutocallEngine<RNG,S>::pathPricer() const {

        boost::shared_ptr<GeneralizedBlackScholesProcess> process =
            boost::dynamic_pointer_cast<GeneralizedBlackScholesProcess>(
                                                      processes_->process(0));
        QL_REQUIRE(process, "Black-Scholes process required");

        // Get the grid
        Size strikeDateIndex;
        std::vector<Size> couponDateIndices;
        TimeGrid grid = getTimeGridAndIndices( strikeDateIndex, couponDateIndices );

        // Find the discount factor to each coupon payment
        const Size numCoupons = couponDateIndices.size();
        std::vector<DiscountFactor> discounts( numCoupons );
        for( Size i=0 ; i<numCoupons ; i++ ) {
            const Size index = couponDateIndices[i];
            discounts[i] = process->riskFreeRate()->discount( grid[index] );
        }

        return boost::shared_ptr<
                         typename MCAutocallEngine<RNG,S>::path_pricer_type>(
            new AutocallMultiPathPricer( 
                arguments_, 
                discounts, 
                strikeDateIndex,
                couponDateIndices                
            ) );
    }

    template <class RNG, class S>
    inline MakeMCAutocallEngine<RNG,S>::MakeMCAutocallEngine(
                     const boost::shared_ptr<StochasticProcessArray>& process)
    : process_(process), stepsPerYear_(Null<Size>()),
      brownianBridge_(false), antithetic_(false),
      samples_(Null<Size>()), maxSamples_(Null<Size>()),
      tolerance_(Null<Real>()), seed_(0) {}

    template <class RNG, class S>
    inline MakeMCAutocallEngine<RNG,S>&
    MakeMCAutocallEngine<RNG,S>::withStepsPerYear(Size steps) {
        stepsPerYear_ = steps;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCAutocallEngine<RNG,S>&
    MakeMCAutocallEngine<RNG,S>::withBrownianBridge(bool brownianBridge) {
        brownianBridge_ = brownianBridge;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCAutocallEngine<RNG,S>&
    MakeMCAutocallEngine<RNG,S>::withAntitheticVariate(bool b) {
        antithetic_ = b;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCAutocallEngine<RNG,S>&
    MakeMCAutocallEngine<RNG,S>::withSamples(Size samples) {
        QL_REQUIRE(tolerance_ == Null<Real>(),
                   "tolerance already set");
        samples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCAutocallEngine<RNG,S>&
    MakeMCAutocallEngine<RNG,S>::withAbsoluteTolerance(Real tolerance) {
        QL_REQUIRE(samples_ == Null<Size>(),
                   "number of samples already set");
        QL_REQUIRE(RNG::allowsErrorEstimate,
                   "chosen random generator policy "
                   "does not allow an error estimate");
        tolerance_ = tolerance;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCAutocallEngine<RNG,S>&
    MakeMCAutocallEngine<RNG,S>::withMaxSamples(Size samples) {
        maxSamples_ = samples;
        return *this;
    }

    template <class RNG, class S>
    inline MakeMCAutocallEngine<RNG,S>&
    MakeMCAutocallEngine<RNG,S>::withSeed(BigNatural seed) {
        seed_ = seed;
        return *this;
    }

    template <class RNG, class S>
    inline
    MakeMCAutocallEngine<RNG,S>::operator boost::shared_ptr<PricingEngine>()
                                                                      const {
        return boost::shared_ptr<PricingEngine>(new
            MCAutocallEngine<RNG,S>(process_,
                                    stepsPerYear_,
                                    brownianBridge_,
                                    antithetic_,
                                    samples_,
                                    tolerance_,
                                    maxSamples_,
                                    seed_));
    }

}

#endif
