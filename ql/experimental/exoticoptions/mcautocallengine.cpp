/* -*- mode: c++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*
 Copyright (C) 2014 Catley Lakeman Ltd.
 The moral rights of the author, David Rees, have been asserted.
 
 This file is part of QuantLib, a free-software/open-source library
 for financial quantitative analysts and developers - http://quantlib.org/
 
 QuantLib is free software: you can redistribute it and/or modify it
 under the terms of the QuantLib license.  You should have received a
 copy of the license along with this program; if not, please email
 <quantlib-dev@lists.sf.net>. The license is also available online at
 <http://quantlib.org/license.shtml>.
 
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the license for more details.
 */

#include <ql/experimental/exoticoptions/mcAutocallengine.hpp>
#include <ql/payoff.hpp>

namespace QuantLib {
    
    AutocallMultiPathPricer::AutocallMultiPathPricer(
                                                     const Autocall::arguments& arguments,
                                                     const std::vector<DiscountFactor>& discounts,
                                                     const Size& strikeDateIndex,
                                                     const std::vector<Size>& couponDateIndices
                                                     )
    :   arguments_(arguments),
    discounts_(discounts),
    strikeDateIndex_(strikeDateIndex),
    couponDateIndices_(couponDateIndices)
    {}
    
    // This is the method where the payout of the autocall is calculated
    // for each MultiPath generated by the Monte Carlo engine
    Real AutocallMultiPathPricer::operator()(const MultiPath& multiPath) const {
        const Size numAssets = multiPath.assetNumber();
        const Size numNodes = multiPath.pathSize();
        const Size numCoupons = couponDateIndices_.size();
        
        QL_REQUIRE( numAssets > 0,
                   "Must specify at least one underlying asset" );
        QL_REQUIRE( numCoupons <= numNodes,
                   "Internal error, fewer path nodes than coupons" );
        
        std::vector<Real> strikeLevels = arguments_.strikeLevels_;
        const Size numstrikeLevels = strikeLevels.size();
        QL_REQUIRE( numAssets==numstrikeLevels || numstrikeLevels==0,
                   "Must have the same number of assets as strike levels " <<
                   "and at least one stike level. " <<
                   " Found " << numAssets << " assets and " <<
                   numstrikeLevels << " strike levels."
                   );
        
        // If strike levels not specified, get then from the simulation
        if( numstrikeLevels == 0 ) {
            QL_REQUIRE( strikeDateIndex_ != AutocallConstants::cNoIndex,
                       "Strike date index not set" );
            QL_REQUIRE( strikeDateIndex_ < numNodes,
                       "Internal error, strikeDateIndex_ is greater than path nodes" );
            
            for( Size i=0 ; i<numAssets ; ++i )
                strikeLevels.push_back( multiPath[i][strikeDateIndex_] );
        }
        
        bool autocall_activated = false;
        Real price = 0.0;
        Size offset = 1;
        
        for( Size i=0 ; i<numCoupons && !autocall_activated ; ++i ) {
            // Which node on the grid does this coupon lie on
            const Size node = couponDateIndices_[i];
            
            const DiscountFactor discount = discounts_[i];
            const Real notional = arguments_.notionals_.size() == 1 ?
            arguments_.notionals_[0] : arguments_.notionals_[i];
            
            // Calculate the level of the underlyings at this time
            Real und_level;
            Array levels(numAssets);
            for( Size j=0 ; j<numAssets ; ++j ) {
            	    levels[j] = multiPath[j][node] / strikeLevels[j];
            }
            und_level = arguments_.underlyingType_->accumulate(levels);
/*
switch (arguments_.underlyingType_) {
                    
                case Autocall::Worst:
                    und_level = QL_MAX_REAL;
                    for( Size j=0 ; j<numAssets ; ++j ) {
                        const Real value = multiPath[j][node];
                        const Real level = value / strikeLevels[j];
                        und_level = std::min( und_level, level );
                    }
                    break;
                case Autocall::Basket:
                    und_level = 0.0;
                    for( Size j=0 ; j<numAssets ; ++j ) {
                        const Real value = multiPath[j][node];
                        const Real level = value / strikeLevels[j];
                        und_level += level;
                    }
                    und_level/=(Real)numAssets;
                    break;
                default:
                    QL_FAIL("Unknown Underlying Type in Autocall");
                    
            }
*/

            // By default we pay the fixed coupon
            Real payment = arguments_.fixedCoupons_.size() == 1 ?
            arguments_.fixedCoupons_[0] : arguments_.fixedCoupons_[i];
            
            // If we reach the autocall level, then pay the autocall amount instead
            if( und_level > arguments_.callLevels_[i] ) {
                payment = arguments_.callPayments_[i];
                autocall_activated = true;
            }
            
            price += payment * notional * discount;
            
            // Pay the redemption amount if autocall not activated
            if( i==numCoupons-1 && !autocall_activated ) {
                const Autocall::RedemptionInfo& redemptionInfo = arguments_.redemptionInfo_;
                
                const Real tmp1 = redemptionInfo.getUpsideGearing() * und_level;
                const Real tmp2 = std::min( redemptionInfo.getCap(), tmp1 );
                const Real final_payment_1 = std::max( redemptionInfo.getCash(), tmp2 );
                
                // Check if the barrier breached
                Real final_payment_2 = 0.0;
                if( und_level < redemptionInfo.getBarrier() ) {
                    const Real tmp3 = redemptionInfo.getDownsideGearing() * (und_level-1.0);
                    const Real tmp4 = std::min( redemptionInfo.getCap2(), tmp3 );
                    final_payment_2 = std::max( redemptionInfo.getFloor(), tmp4 );
                }
                
                const Real redemptionPayment = 
                (final_payment_1 + final_payment_2) * notional * discount;
                
                price += redemptionPayment;
            }
        }
        
        return price;
    }
    
}

